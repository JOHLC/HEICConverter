name: Build and Validate

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  validate:
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Install ImageMagick
      run: |
        Write-Host "üîÑ Installing ImageMagick..."
        
        # First, check if ImageMagick is already available
        try {
          $existingVersion = magick -version 2>$null
          if ($existingVersion) {
            Write-Host "‚úÖ ImageMagick is already installed and accessible"
            Write-Host "   Version: $($existingVersion.Split("`n")[0])"
            exit 0
          }
        } catch {
          Write-Host "‚ÑπÔ∏è  ImageMagick not currently accessible, proceeding with installation..."
        }
        
        # Try multiple installation methods
        $installSuccess = $false
        
        # Method 1: Try winget with specific source
        Write-Host "üîÑ Trying winget installation method..."
        try {
          $result = winget install --id ImageMagick.ImageMagick --source winget --accept-source-agreements --accept-package-agreements --silent
          if ($LASTEXITCODE -eq 0) {
            Write-Host "‚úÖ ImageMagick installed successfully via winget"
            $installSuccess = $true
          } elseif ($LASTEXITCODE -eq -1978335189) {
            Write-Host "‚ö†Ô∏è  Winget installation failed with known error code, trying alternative method..."
          } else {
            Write-Host "‚ö†Ô∏è  Winget installation failed with exit code $LASTEXITCODE, trying alternative method..."
          }
        } catch {
          Write-Host "‚ö†Ô∏è  Winget installation encountered an error: $($_.Exception.Message)"
        }
        
        # Method 2: Try chocolatey as fallback
        if (-not $installSuccess) {
          Write-Host "üîÑ Trying chocolatey installation method..."
          try {
            # Install chocolatey if not present
            if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
              Write-Host "Installing Chocolatey..."
              Set-ExecutionPolicy Bypass -Scope Process -Force
              [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
              Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
            }
            
            # Install ImageMagick via chocolatey
            choco install imagemagick -y --no-progress
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úÖ ImageMagick installed successfully via chocolatey"
              $installSuccess = $true
              # Refresh environment variables
              $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
            }
          } catch {
            Write-Host "‚ö†Ô∏è  Chocolatey installation failed: $($_.Exception.Message)"
          }
        }
        
        # Final verification
        if ($installSuccess) {
          Start-Sleep -Seconds 5  # Give time for PATH updates
          try {
            $version = magick -version 2>$null
            if ($version) {
              Write-Host "‚úÖ ImageMagick installation verified successfully"
              Write-Host "   Version: $($version.Split("`n")[0])"
            } else {
              Write-Error "‚ùå ImageMagick installed but not accessible in PATH"
              exit 1
            }
          } catch {
            Write-Error "‚ùå ImageMagick installation verification failed: $($_.Exception.Message)"
            exit 1
          }
        } else {
          Write-Error "‚ùå All ImageMagick installation methods failed"
          exit 1
        }
    
    - name: Verify ImageMagick Installation
      run: |
        magick -version
    
    - name: Install PS2EXE Module
      run: |
        try {
          Install-Module -Name PS2EXE -Force -AllowClobber -Scope CurrentUser
          Write-Host "‚úÖ PS2EXE module installed successfully"
        } catch {
          Write-Error "‚ùå Failed to install PS2EXE module: $($_.Exception.Message)"
          exit 1
        }
    
    - name: Validate PowerShell Script Syntax
      run: |
        $scriptPath = "build/PS2EXE/HEICConverter.ps1"
        $errors = $null
        $null = [System.Management.Automation.PSParser]::Tokenize((Get-Content $scriptPath -Raw), [ref]$errors)
        if ($errors) {
          Write-Error "PowerShell syntax errors found:"
          $errors | ForEach-Object { Write-Error $_ }
          exit 1
        } else {
          Write-Host "‚úÖ PowerShell script syntax is valid"
        }
    
    - name: Build Executable
      run: |
        cd build/PS2EXE
        .\PS2EXE.ps1
        if (-not (Test-Path "HEICConverter.exe")) {
          Write-Error "‚ùå Failed to build executable"
          exit 1
        } else {
          Write-Host "‚úÖ Executable built successfully"
          Get-Item "HEICConverter.exe" | Select-Object Name, Length, LastWriteTime
        }
        
        # Verify icon.ico exists for runtime icon loading
        if (-not (Test-Path "icon.ico")) {
          Write-Error "‚ùå icon.ico not found - required for runtime icon display"
          exit 1
        } else {
          Write-Host "‚úÖ icon.ico verified"
          Get-Item "icon.ico" | Select-Object Name, Length, LastWriteTime
        }
    
    - name: Upload Build Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: HEICConverter-exe
        path: |
          build/PS2EXE/HEICConverter.exe
          build/PS2EXE/icon.ico
        retention-days: 30